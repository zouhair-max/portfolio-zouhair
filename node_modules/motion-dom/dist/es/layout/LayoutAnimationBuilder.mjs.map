{"version":3,"file":"LayoutAnimationBuilder.mjs","sources":["../../../src/layout/LayoutAnimationBuilder.ts"],"sourcesContent":["import type { Box } from \"motion-utils\"\nimport { GroupAnimation } from \"../animation/GroupAnimation\"\nimport type {\n    AnimationOptions,\n    AnimationPlaybackControls,\n    Transition,\n} from \"../animation/types\"\nimport { frame } from \"../frameloop\"\nimport { copyBoxInto } from \"../projection/geometry/copy\"\nimport { createBox } from \"../projection/geometry/models\"\nimport { HTMLProjectionNode } from \"../projection/node/HTMLProjectionNode\"\nimport type { IProjectionNode } from \"../projection/node/types\"\nimport { HTMLVisualElement } from \"../render/html/HTMLVisualElement\"\nimport { visualElementStore } from \"../render/store\"\nimport type { VisualElement } from \"../render/VisualElement\"\nimport { resolveElements, type ElementOrSelector } from \"../utils/resolve-elements\"\n\ntype LayoutAnimationScope = Element | Document\n\ninterface LayoutElementRecord {\n    element: Element\n    visualElement: VisualElement\n    projection: IProjectionNode\n}\n\ninterface LayoutAttributes {\n    layout?: boolean | \"position\" | \"size\" | \"preserve-aspect\"\n    layoutId?: string\n}\n\ntype LayoutBuilderResolve = (animation: GroupAnimation) => void\ntype LayoutBuilderReject = (error: unknown) => void\n\ninterface ProjectionOptions {\n    layout?: boolean | \"position\" | \"size\" | \"preserve-aspect\"\n    layoutId?: string\n    animationType?: \"size\" | \"position\" | \"both\" | \"preserve-aspect\"\n    transition?: Transition\n    crossfade?: boolean\n}\n\nconst layoutSelector = \"[data-layout], [data-layout-id]\"\nconst noop = () => {}\nfunction snapshotFromTarget(projection: IProjectionNode): LayoutElementRecord[\"projection\"][\"snapshot\"] {\n    const target = projection.targetWithTransforms || projection.target\n    if (!target) return undefined\n\n    const measuredBox = createBox()\n    const layoutBox = createBox()\n    copyBoxInto(measuredBox, target as Box)\n    copyBoxInto(layoutBox, target as Box)\n\n    return {\n        animationId: projection.root?.animationId ?? 0,\n        measuredBox,\n        layoutBox,\n        latestValues: projection.animationValues || projection.latestValues || {},\n        source: projection.id,\n    }\n}\n\nexport class LayoutAnimationBuilder {\n    private scope: LayoutAnimationScope\n    private updateDom: () => void | Promise<void>\n    private defaultOptions?: AnimationOptions\n    private sharedTransitions = new Map<string, AnimationOptions>()\n    private notifyReady: LayoutBuilderResolve = noop\n    private rejectReady: LayoutBuilderReject = noop\n    private readyPromise: Promise<GroupAnimation>\n\n    constructor(\n        scope: LayoutAnimationScope,\n        updateDom: () => void | Promise<void>,\n        defaultOptions?: AnimationOptions\n    ) {\n        this.scope = scope\n        this.updateDom = updateDom\n        this.defaultOptions = defaultOptions\n\n        this.readyPromise = new Promise<GroupAnimation>((resolve, reject) => {\n            this.notifyReady = resolve\n            this.rejectReady = reject\n        })\n\n        frame.postRender(() => {\n            this.start().then(this.notifyReady).catch(this.rejectReady)\n        })\n    }\n\n    shared(id: string, transition: AnimationOptions): this {\n        this.sharedTransitions.set(id, transition)\n        return this\n    }\n\n    then(\n        resolve: LayoutBuilderResolve,\n        reject?: LayoutBuilderReject\n    ): Promise<void> {\n        return this.readyPromise.then(resolve, reject)\n    }\n\n    private async start(): Promise<GroupAnimation> {\n        const beforeElements = collectLayoutElements(this.scope)\n        const beforeRecords = this.buildRecords(beforeElements)\n\n        beforeRecords.forEach(({ projection }) => {\n            const hasCurrentAnimation = Boolean(projection.currentAnimation)\n            const isSharedLayout = Boolean(projection.options.layoutId)\n            if (hasCurrentAnimation && isSharedLayout) {\n                const snapshot = snapshotFromTarget(projection)\n                if (snapshot) {\n                    projection.snapshot = snapshot\n                } else if (projection.snapshot) {\n                    projection.snapshot = undefined\n                }\n            } else if (\n                projection.snapshot &&\n                (projection.currentAnimation || projection.isProjecting())\n            ) {\n                projection.snapshot = undefined\n            }\n            projection.isPresent = true\n            projection.willUpdate()\n        })\n\n        await this.updateDom()\n\n        const afterElements = collectLayoutElements(this.scope)\n        const afterRecords = this.buildRecords(afterElements)\n        this.handleExitingElements(beforeRecords, afterRecords)\n\n        afterRecords.forEach(({ projection }) => {\n            const instance = projection.instance as HTMLElement | undefined\n            const resumeFromInstance = projection.resumeFrom\n                ?.instance as HTMLElement | undefined\n            if (!instance || !resumeFromInstance) return\n            if (!(\"style\" in instance)) return\n\n            const currentTransform = instance.style.transform\n            const resumeFromTransform = resumeFromInstance.style.transform\n\n            if (\n                currentTransform &&\n                resumeFromTransform &&\n                currentTransform === resumeFromTransform\n            ) {\n                instance.style.transform = \"\"\n                instance.style.transformOrigin = \"\"\n            }\n        })\n\n        afterRecords.forEach(({ projection }) => {\n            projection.isPresent = true\n        })\n\n        const root = getProjectionRoot(afterRecords, beforeRecords)\n        root?.didUpdate()\n\n        await new Promise<void>((resolve) => {\n            frame.postRender(() => resolve())\n        })\n\n        const animations = collectAnimations(afterRecords)\n        const animation = new GroupAnimation(animations)\n\n        return animation\n    }\n\n    private buildRecords(elements: Element[]): LayoutElementRecord[] {\n        const records: LayoutElementRecord[] = []\n        const recordMap = new Map<Element, LayoutElementRecord>()\n\n        for (const element of elements) {\n            const parentRecord = findParentRecord(element, recordMap, this.scope)\n            const { layout, layoutId } = readLayoutAttributes(element)\n            const override = layoutId\n                ? this.sharedTransitions.get(layoutId)\n                : undefined\n            const transition = override || this.defaultOptions\n            const record = getOrCreateRecord(element, parentRecord?.projection, {\n                layout,\n                layoutId,\n                animationType: typeof layout === \"string\" ? layout : \"both\",\n                transition: transition as Transition,\n            })\n            recordMap.set(element, record)\n            records.push(record)\n        }\n\n        return records\n    }\n\n    private handleExitingElements(\n        beforeRecords: LayoutElementRecord[],\n        afterRecords: LayoutElementRecord[]\n    ): void {\n        const afterElementsSet = new Set(afterRecords.map((record) => record.element))\n\n        beforeRecords.forEach((record) => {\n            if (afterElementsSet.has(record.element)) return\n\n            // For shared layout elements, relegate to set up resumeFrom\n            // so the remaining element animates from this position\n            if (record.projection.options.layoutId) {\n                record.projection.isPresent = false\n                record.projection.relegate()\n            }\n\n            record.visualElement.unmount()\n            visualElementStore.delete(record.element)\n        })\n\n        // Clear resumeFrom on EXISTING nodes that point to unmounted projections\n        // This prevents crossfade animation when the source element was removed entirely\n        // But preserve resumeFrom for NEW nodes so they can animate from the old position\n        // Also preserve resumeFrom for lead nodes that were just promoted via relegate\n        const beforeElementsSet = new Set(beforeRecords.map((record) => record.element))\n        afterRecords.forEach(({ element, projection }) => {\n            if (\n                beforeElementsSet.has(element) &&\n                projection.resumeFrom &&\n                !projection.resumeFrom.instance &&\n                !projection.isLead()\n            ) {\n                projection.resumeFrom = undefined\n                projection.snapshot = undefined\n            }\n        })\n    }\n}\n\nexport function parseAnimateLayoutArgs(\n    scopeOrUpdateDom: ElementOrSelector | (() => void),\n    updateDomOrOptions?: (() => void) | AnimationOptions,\n    options?: AnimationOptions\n): {\n    scope: Element | Document\n    updateDom: () => void\n    defaultOptions?: AnimationOptions\n} {\n    // animateLayout(updateDom)\n    if (typeof scopeOrUpdateDom === \"function\") {\n        return {\n            scope: document,\n            updateDom: scopeOrUpdateDom,\n            defaultOptions: updateDomOrOptions as AnimationOptions | undefined,\n        }\n    }\n\n    // animateLayout(scope, updateDom, options?)\n    const elements = resolveElements(scopeOrUpdateDom)\n    const scope = elements[0] || document\n\n    return {\n        scope,\n        updateDom: updateDomOrOptions as () => void,\n        defaultOptions: options,\n    }\n}\n\nfunction collectLayoutElements(scope: LayoutAnimationScope): Element[] {\n    const elements = Array.from(scope.querySelectorAll(layoutSelector))\n\n    if (scope instanceof Element && scope.matches(layoutSelector)) {\n        if (!elements.includes(scope)) {\n            elements.unshift(scope)\n        }\n    }\n\n    return elements\n}\n\nfunction readLayoutAttributes(element: Element): LayoutAttributes {\n    const layoutId = element.getAttribute(\"data-layout-id\") || undefined\n    const rawLayout = element.getAttribute(\"data-layout\")\n    let layout: LayoutAttributes[\"layout\"]\n\n    if (rawLayout === \"\" || rawLayout === \"true\") {\n        layout = true\n    } else if (rawLayout) {\n        layout = rawLayout as LayoutAttributes[\"layout\"]\n    }\n\n    return {\n        layout,\n        layoutId,\n    }\n}\n\nfunction createVisualState() {\n    return {\n        latestValues: {},\n        renderState: {\n            transform: {},\n            transformOrigin: {},\n            style: {},\n            vars: {},\n        },\n    }\n}\n\nfunction getOrCreateRecord(\n    element: Element,\n    parentProjection?: IProjectionNode,\n    projectionOptions?: ProjectionOptions\n): LayoutElementRecord {\n    const existing = visualElementStore.get(element) as VisualElement | undefined\n    const visualElement =\n        existing ??\n        new HTMLVisualElement(\n            {\n                props: {},\n                presenceContext: null,\n                visualState: createVisualState(),\n            },\n            { allowProjection: true }\n        )\n\n    if (!existing || !visualElement.projection) {\n        visualElement.projection = new HTMLProjectionNode(\n            visualElement.latestValues,\n            parentProjection\n        )\n    }\n\n    visualElement.projection.setOptions({\n        ...projectionOptions,\n        visualElement,\n    })\n\n    if (!visualElement.current) {\n        visualElement.mount(element as HTMLElement)\n    } else if (!visualElement.projection.instance) {\n        // Mount projection if VisualElement is already mounted but projection isn't\n        // This happens when animate() was called before animateLayout()\n        visualElement.projection.mount(element as HTMLElement)\n    }\n\n    if (!existing) {\n        visualElementStore.set(element, visualElement)\n    }\n\n    return {\n        element,\n        visualElement,\n        projection: visualElement.projection as IProjectionNode,\n    }\n}\n\nfunction findParentRecord(\n    element: Element,\n    recordMap: Map<Element, LayoutElementRecord>,\n    scope: LayoutAnimationScope\n) {\n    let parent = element.parentElement\n\n    while (parent) {\n        const record = recordMap.get(parent)\n        if (record) return record\n\n        if (parent === scope) break\n        parent = parent.parentElement\n    }\n\n    return undefined\n}\n\nfunction getProjectionRoot(\n    afterRecords: LayoutElementRecord[],\n    beforeRecords: LayoutElementRecord[]\n) {\n    const record = afterRecords[0] || beforeRecords[0]\n    return record?.projection.root\n}\n\nfunction collectAnimations(afterRecords: LayoutElementRecord[]) {\n    const animations = new Set<AnimationPlaybackControls>()\n\n    afterRecords.forEach((record) => {\n        const animation = record.projection.currentAnimation\n        if (animation) animations.add(animation)\n    })\n\n    return Array.from(animations)\n}\n"],"names":[],"mappings":"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"}